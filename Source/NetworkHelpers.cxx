#define _WINSOCKAPI_    // stops windows.h including winsock.h
#include "NetworkHelpers.h"

#include <WS2tcpip.h>
#include <Shlwapi.h>

#include <vector>

#ifndef SERVER_ADDRESS
#define SERVER_ADDRESS "127.0.0.1"
#endif

// This function basically opens a network socket, sends the stream and closes
// This is inefficient but this is just a quick prototype
bool SendStream(IStream *pStream) {
    // Initialize Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return false;
    }

    // Create a socket
    SOCKET sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sockfd == INVALID_SOCKET) {
        WSACleanup();
        return false;
    }

    // Server address
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(1337); // Port to send data to 
    inet_pton(AF_INET, SERVER_ADDRESS, &serverAddr.sin_addr);

    // Connect to the server
    if (connect(sockfd, reinterpret_cast<struct sockaddr*>(&serverAddr), sizeof(serverAddr)) == SOCKET_ERROR) {
        closesocket(sockfd);
        WSACleanup();
        return false;
    }

    // Get the size of the stream
    STATSTG stat;
    if (FAILED(pStream->Stat(&stat, STATFLAG_NONAME))) {
        return false;
    }

    // Send data
    // TODO: Improve this code to send data in chunks
    std::vector<BYTE> bytes{};
    {
        bytes.resize(stat.cbSize.QuadPart);

        // Read the stream to the bytes vector
        ULONG bytesRead;
        HRESULT hr = pStream->Read(bytes.data(), static_cast<ULONG>(stat.cbSize.QuadPart), &bytesRead);
        
        if (FAILED(hr)) return false;

        // Read the stream data into bytes vector
        int bytesSent = send(sockfd, reinterpret_cast<const char *>(bytes.data()), bytes.size(), 0);
        if (bytesSent == SOCKET_ERROR) {
            closesocket(sockfd);
            WSACleanup();
            return false;
        }
    }

    closesocket(sockfd);
    WSACleanup();
    return true;
}